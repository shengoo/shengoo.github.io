title: 性能优化之：HTTP 缓存
link: http://www.sheng00.com/2121.html
author: admin
description: 
post_id: 2121
created: 2015/07/15 10:10:17
created_gmt: 2015/07/15 02:10:17
comment_status: open
post_name: %e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e4%b9%8b%ef%bc%9ahttp-%e7%bc%93%e5%ad%98
status: publish
post_type: post

# 性能优化之：HTTP 缓存

通过网络获取内容既缓慢，成本又高：大的响应需要在客户端和服务器之间进行多次往返通信，这拖延了浏览器可以使用和处理内容的时间，同时也增加了访问者的数据成本。因此，缓存和重用以前获取的资源的能力成为优化性能很关键的一个方面。 好消息是每个浏览器都实现了 HTTP 缓存！ 我们所要做的就是，确保每个服务器响应都提供正确的 HTTP 头指令，以指导浏览器何时可以缓存响应以及可以缓存多久。 

> 如果在应用中使用 Webview 来获取和显示网页内容，可能需要提供额外的配置标志，以确保启用了 HTTP 缓存，并根据用途设置了合理的缓存大小，同时，确保缓存持久化。查看平台文档并确认您的设置！ 

![http-request](/wp-content/uploads/2015/07/http-request.png) 服务器在返回响应时，还会发出一组 HTTP 头，用来描述内容类型、长度、缓存指令、验证令牌等。例如，在上图的交互中，服务器返回了一个 1024 字节的响应，指导客户端缓存响应长达 120 秒，并提供验证令牌（`x234dff`），在响应过期之后，可以用来验证资源是否被修改。 

### Expires和Cache-Control: max-age标头

这些标头用于指定相应时间段，浏览器可在指定的这段时间内使用已缓存的资源，而无需查看网络服务器是否提供了新版资源。这些缓存标头功能强大，没有任何应用条件限制。在设置这些标头并下载资源后，浏览器不会为资源发出任何GET请求，除非过期日期到期或达到时间最大值，亦或是用户清除了缓存。 

### Last-Modifed和ETag标头

这些标头可用于指定浏览器应如何确定用于缓存的文件是否相同。在`Last-Modified`标头中指定的是日期，而在`ETag`标头中指定的则可以是唯一标识资源的任意值（通常为文件版本或内容哈希值）。`Last-Modified`是功能“较弱”的缓存标头，因为浏览器会使用试探法来确定是否需要从缓存中抓取内容。 借助这些标头，浏览器可以通过在用户明确重新加载页面时发出条件式GET请求，有效地更新其已缓存资源。除非您在服务器端更改资源，否则条件式GET请求不会返回完整的响应，因此相较于完整GET请求，此类请求的延迟较小。 

### 我应使用哪个缓存标头？

对于所有可缓存资源，指定一个`Expires`或`Cache-Control max-age`以及一个`Last-Modified`或`ETag`至关重要。您没必要同时指定`Expires`和`Cache-Control: max-age`；或同时指定`Last-Modified`和`ETag`。 

## 使用 ETag 验证缓存的响应

>   * 服务器通过 ETag HTTP 头传递验证令牌
>   * 通过验证令牌可以进行高效的资源更新检查：如果资源未更改，则不会传输任何数据。

让我们假设在首次获取资源 120 秒之后，浏览器又对该资源发起了新请求。首先，浏览器会检查本地缓存并找到之前的响应，不幸的是，这个响应现在已经’过期’，无法在使用。此时，浏览器也可以直接发出新请求，获取新的完整响应，但是这样做效率较低，因为如果资源未被更改过，我们就没有理由再去下载与缓存中已有的完全相同的字节。 这就是 ETag 头中指定的验证令牌所要解决的问题：服务器会生成并返回一个随机令牌，通常是文件内容的哈希值或者某个其他指纹码。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其发送给服务器：如果指纹码仍然一致，说明资源未被修改，我们就可以跳过下载。 ![http-cache-control](/wp-content/uploads/2015/07/http-cache-control.png) 在上面的例子中，客户端自动在If-None-MatchHTTP 请求头中提供 ETag 令牌，服务器针对当前的资源检查令牌，如果未被修改过，则返回304 Not Modified响应，告诉浏览器缓存中的响应未被修改过，可以再延用 120 秒。注意，我们不必再次下载响应 - 这节约了时间和带宽。 作为网络开发人员，您如何利用高效的重新验证？ 浏览器代替我们完成了所有的工作：自动检测是否已指定了验证令牌，并会将验证令牌附加到发出的请求上，根据从服务器收到的响应，在必要时更新缓存时间戳。**实际上，我们唯一要做的就是确保服务器提供必要的 ETag 令牌：查看服务器文档中是否有必要的配置标志。**

> 提示：HTML5 Boilerplate 项目包含了所有最流行的服务器的配置文件样例，并且为每个配置标志和设置都提供了详细的注释：在列表中找到您喜欢的服务器，查找适合的设置，然后复制/确认您的服务器配置了推荐的设置。 

## Cache-Control

>   * 每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略
>   * Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久

最好的请求是不必与服务器进行通信的请求：通过响应的本地副本，我们可以避免所有的网络延迟以及数据传输的数据成本。为此，HTTP 规范允许服务器返回 [一系列不同的 Cache-Control 指令](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)，控制浏览器或者其他中继缓存如何缓存某个响应以及缓存多长时间。 

> Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。 

![http-cache-control-highlight](/wp-content/uploads/2015/07/http-cache-control-highlight.png)

### no-cache 和 no-store

`no-cache`表示必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。 相比之下，`no-store`更加简单，直接禁止浏览器和所有中继缓存存储返回的任何版本的响应 - 例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应。 

### public和 private

如果响应被标记为`public`，即使有关联的 HTTP 认证，甚至响应状态码无法正常缓存，响应也可以被缓存。大多数情况下，`public`不是必须的，因为明确的缓存信息（例如`max-age`）已表示 响应可以被缓存。 相比之下，浏览器可以缓存`private`响应，但是通常只为单个用户缓存，因此，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是 CDN 不能缓存。 

### max-age

该指令指定从当前请求开始，允许获取的响应被重用的最长时间（单位为秒） - 例如：`max-age=60`表示响应可以再缓存和重用 60 秒。 

## 定义最优 Cache-Control 策略

![http-cache-decision-tree](/wp-content/uploads/2015/07/http-cache-decision-tree.png)